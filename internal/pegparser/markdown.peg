{
package pegparser

type Markdown struct {
    Lines []string
}

func anyToString(value any) string {
	switch v := value.(type) {
    case string:
        return v
    case []any:
        byteArr, err := interfaceSliceToByteSlice(v)
        if err != nil {
            return fmt.Sprintf("%v", v)
        }
        return string(byteArr)
    case []uint8:
        return strings.TrimSpace(string(v))
	default:
		return fmt.Sprintf("%v", v)
	}
}

func interfaceSliceToByteSlice(data []any) ([]byte, error) {
	result := make([]uint8, 0, len(data))
	for _, v := range data {
		if b, ok := v.([]uint8); ok {
			result = append(result, b[0])
		} else {
			return nil, fmt.Errorf("type assertion failed: expected byte, got %T", v)
		}
	}
	return result, nil
}

func convertToStrings(data []interface{}) ([]string, error) {
    var result []string
    for _, v := range data {
        if str, ok := v.(string); ok {
            result = append(result, str)
        } else {
            return []string{}, errors.New(fmt.Sprintf("Warning: Non-string value encountered: %v\n", v))
        }
    }
    return result, nil
}
}

Markdown <- elements:(ElementBlankLine)* element:Element? EOF {
    var lines []string
    elems, _ := convertToStrings(elements.([]interface{}))
    lines = append(lines, elems...)

    if element != nil {
        lines = append(lines, element.(string))
    }

    return Markdown{
        Lines: lines,
    }, nil
}

Element <- element:(Link / Heading / Paragraph) {
    return element.(string), nil
}

ElementBlankLine <- element:Element BlankLine {
    return element.(string), nil
}
Heading <- (HeadingSix / HeadingFive / HeadingFour / HeadingThree / HeadingTwo / HeadingOne )

HeadingOne <- "#" Spacing text:Text {
    return fmt.Sprintf("<h1>%s</h1>", text.(string)), nil
}

HeadingTwo <- "##" Spacing text:Text {
    return fmt.Sprintf("<h2>%s</h2>", text.(string)), nil
}

HeadingThree <- "###" Spacing text:Text {
    return fmt.Sprintf("<h3>%s</h3>", text.(string)), nil
}

HeadingFour <- "####" Spacing text:Text {
    return fmt.Sprintf("<h4>%s</h4>", text.(string)), nil
}

HeadingFive <- "#####" Spacing text:Text {
    return fmt.Sprintf("<h5>%s</h5>", text.(string)), nil
}

HeadingSix <- "######" Spacing text:Text {
    return fmt.Sprintf("<h6>%s</h6>", text.(string)), nil
}

Paragraph <- text:(MultilineText / Text) {
    if strings.TrimSpace(string(c.text)) == "" {
        return "", nil
    }
    return "<p>" + text.(string) + "</p>", nil
}

MultilineText <- text1:Text Newline text2:Text {
    if text2.(string) == "" {
       return text1.(string), nil
    }
    return text1.(string) + "\n" + text2.(string), nil
}

Link <- "[" text:LinkText "]" "(" url:URL ")" {
    return "<a href=\"" + anyToString(url) + "\">" + anyToString(text) + "</a>", nil
}

Text <- text:(Link / NormalText)* {
    switch val := text.(type) {
    case string: 
        return val, nil
    case []any:
        var sArr []string
        for _, v := range val {
			sArr = append(sArr, v.(string))
		}
        return strings.Join(sArr, ""), nil
    default: 
        return "", errors.New(fmt.Sprintf("could not handle %v properly", text))
    }
}

NormalText <- (!"[" !"]" !"\n" .)+ {
    return string(c.text), nil
}

URL <- [^) \t\n]+
LinkText <- [^\]]+
BlankLine <- Newline+
Newline <- "\n"
Spacing <- [ \t]*
EOF <- !.